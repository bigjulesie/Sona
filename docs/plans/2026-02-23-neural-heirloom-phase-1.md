# Neural Heirloom — Phase 1 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a working RAG-powered portrait platform where authorised users can converse with an AI representation of Kirit Shah, grounded in curated source material.

**Architecture:** Next.js 14 App Router frontend talks to API routes that implement a RAG pipeline — embed user query via OpenAI, retrieve relevant knowledge chunks from Supabase pgvector, inject into a persona system prompt, stream response via Claude. Access control is enforced at the database level via RLS with a four-tier relationship model.

**Tech Stack:** Next.js 14 (App Router, TypeScript), Supabase (PostgreSQL + pgvector, Auth, RLS, Storage), Anthropic Claude API, OpenAI Embeddings API, Resend, Tailwind CSS, Vercel

---

## Task 1: Scaffold Next.js App

**Files:**
- Create: `package.json`, `tsconfig.json`, `next.config.ts`, `tailwind.config.ts`, `postcss.config.mjs`, `src/app/layout.tsx`, `src/app/page.tsx`, `.env.local.example`, `.gitignore`

**Step 1: Create Next.js app**

Run:
```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --use-npm
```
Expected: Next.js 14 scaffolded in current directory with App Router, TypeScript, Tailwind, ESLint, src directory.

**Step 2: Install project dependencies**

Run:
```bash
npm install @supabase/supabase-js @supabase/ssr @anthropic-ai/sdk openai resend
npm install -D supabase vitest @testing-library/react @testing-library/jest-dom jsdom @types/node
```

**Step 3: Create `.env.local.example`**

Create file `.env.local.example`:
```
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=

# Anthropic
ANTHROPIC_API_KEY=

# OpenAI (embeddings only)
OPENAI_API_KEY=

# Resend
RESEND_API_KEY=

# App
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

**Step 4: Create `.env.local` from example (do NOT commit)**

Copy `.env.local.example` to `.env.local`. Add real keys later.

**Step 5: Verify `.gitignore` includes `.env.local`**

Confirm `.env.local` is in `.gitignore` (create-next-app should handle this). Also add:
```
.env.local
.env*.local
```

**Step 6: Initialize git and commit**

Run:
```bash
git init
git add .
git commit -m "chore: scaffold Next.js 14 app with dependencies"
```

---

## Task 2: Supabase Project Setup & Local Dev

**Files:**
- Create: `supabase/config.toml` (generated by `supabase init`)

**Step 1: Initialize Supabase locally**

Run:
```bash
npx supabase init
```
Expected: Creates `supabase/` directory with `config.toml`.

**Step 2: Link to remote Supabase project**

> **Manual prerequisite:** Create a Supabase project at https://supabase.com/dashboard. Note the project ref, URL, anon key, and service role key. Enable the `pgvector` extension in the SQL editor: `CREATE EXTENSION IF NOT EXISTS vector;`

Run:
```bash
npx supabase link --project-ref <your-project-ref>
```

**Step 3: Populate `.env.local` with Supabase credentials**

Fill in `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, and `SUPABASE_SERVICE_ROLE_KEY` from the Supabase dashboard.

**Step 4: Commit**

Run:
```bash
git add supabase/
git commit -m "chore: initialize Supabase local dev"
```

---

## Task 3: Database Migration — Core Schema

**Files:**
- Create: `supabase/migrations/00001_core_schema.sql`

**Step 1: Create migration file**

Create `supabase/migrations/00001_core_schema.sql`:

```sql
-- Enable pgvector
CREATE EXTENSION IF NOT EXISTS vector;

-- Access tier enum
CREATE TYPE access_tier AS ENUM ('public', 'acquaintance', 'colleague', 'family');

-- Portraits table
CREATE TABLE portraits (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT UNIQUE NOT NULL,
  display_name TEXT NOT NULL,
  system_prompt TEXT NOT NULL,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Profiles table (extends Supabase auth.users)
CREATE TABLE profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  full_name TEXT,
  access_tier access_tier NOT NULL DEFAULT 'public',
  portrait_id UUID REFERENCES portraits(id) ON DELETE SET NULL,
  invited_by UUID REFERENCES profiles(id),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Knowledge chunks table (RAG source material)
CREATE TABLE knowledge_chunks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  portrait_id UUID NOT NULL REFERENCES portraits(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  embedding vector(1536),
  source_title TEXT,
  source_type TEXT,
  source_date DATE,
  min_tier access_tier NOT NULL DEFAULT 'public',
  chunk_index INTEGER NOT NULL DEFAULT 0,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Conversations table
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  portrait_id UUID NOT NULL REFERENCES portraits(id) ON DELETE CASCADE,
  title TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Messages table
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
  content TEXT NOT NULL,
  tokens_used INTEGER,
  chunks_referenced UUID[] DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Audit log table (immutable)
CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action TEXT NOT NULL,
  resource_type TEXT NOT NULL,
  resource_id UUID,
  metadata JSONB DEFAULT '{}',
  ip_address INET,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Indexes
CREATE INDEX idx_knowledge_chunks_portrait ON knowledge_chunks(portrait_id);
CREATE INDEX idx_knowledge_chunks_embedding ON knowledge_chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
CREATE INDEX idx_conversations_user ON conversations(user_id);
CREATE INDEX idx_messages_conversation ON messages(conversation_id);
CREATE INDEX idx_audit_log_user ON audit_log(user_id);
CREATE INDEX idx_audit_log_action ON audit_log(action);

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER portraits_updated_at BEFORE UPDATE ON portraits FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER profiles_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at();
CREATE TRIGGER conversations_updated_at BEFORE UPDATE ON conversations FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Step 2: Commit migration**

Run:
```bash
git add supabase/migrations/
git commit -m "feat: add core database schema migration"
```

---

## Task 4: Database Migration — RLS Policies

**Files:**
- Create: `supabase/migrations/00002_rls_policies.sql`

**Step 1: Create RLS migration**

Create `supabase/migrations/00002_rls_policies.sql`:

```sql
-- Enable RLS on all tables
ALTER TABLE portraits ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_log ENABLE ROW LEVEL SECURITY;

-- Portraits: readable by all authenticated users
CREATE POLICY "Portraits are viewable by authenticated users"
  ON portraits FOR SELECT
  TO authenticated
  USING (true);

-- Profiles: users can read their own profile
CREATE POLICY "Users can view own profile"
  ON profiles FOR SELECT
  TO authenticated
  USING (id = auth.uid());

-- Profiles: users can update their own profile (not access_tier)
CREATE POLICY "Users can update own profile"
  ON profiles FOR UPDATE
  TO authenticated
  USING (id = auth.uid())
  WITH CHECK (id = auth.uid());

-- Knowledge chunks: tiered access control
-- Maps access_tier enum to numeric value for comparison
CREATE OR REPLACE FUNCTION tier_level(t access_tier) RETURNS INTEGER AS $$
BEGIN
  RETURN CASE t
    WHEN 'public' THEN 0
    WHEN 'acquaintance' THEN 1
    WHEN 'colleague' THEN 2
    WHEN 'family' THEN 3
  END;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE POLICY "Knowledge chunks filtered by user access tier"
  ON knowledge_chunks FOR SELECT
  TO authenticated
  USING (
    tier_level((SELECT access_tier FROM profiles WHERE id = auth.uid()))
    >= tier_level(min_tier)
  );

-- Conversations: users can only see their own
CREATE POLICY "Users can view own conversations"
  ON conversations FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "Users can create conversations"
  ON conversations FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update own conversations"
  ON conversations FOR UPDATE
  TO authenticated
  USING (user_id = auth.uid());

-- Messages: users can see messages in their own conversations
CREATE POLICY "Users can view messages in own conversations"
  ON messages FOR SELECT
  TO authenticated
  USING (
    conversation_id IN (
      SELECT id FROM conversations WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create messages in own conversations"
  ON messages FOR INSERT
  TO authenticated
  WITH CHECK (
    conversation_id IN (
      SELECT id FROM conversations WHERE user_id = auth.uid()
    )
  );

-- Audit log: insert-only for service role, no user reads
-- (accessed via service role key in API routes, not directly by users)
CREATE POLICY "Service role can insert audit logs"
  ON audit_log FOR INSERT
  TO service_role
  WITH CHECK (true);

CREATE POLICY "Service role can read audit logs"
  ON audit_log FOR SELECT
  TO service_role
  USING (true);
```

**Step 2: Commit**

Run:
```bash
git add supabase/migrations/
git commit -m "feat: add RLS policies with tiered knowledge access"
```

---

## Task 5: Database Migration — Profile Auto-Creation

**Files:**
- Create: `supabase/migrations/00003_profile_trigger.sql`

**Step 1: Create profile trigger migration**

Create `supabase/migrations/00003_profile_trigger.sql`:

```sql
-- Auto-create profile when a new user signs up
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO profiles (id, email, full_name, access_tier)
  VALUES (
    NEW.id,
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    COALESCE(
      (NEW.raw_user_meta_data->>'access_tier')::access_tier,
      'public'
    )
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION handle_new_user();
```

**Step 2: Commit**

Run:
```bash
git add supabase/migrations/
git commit -m "feat: add auto-create profile trigger on user signup"
```

---

## Task 6: Push Migrations to Remote Supabase

**Step 1: Push all migrations**

Run:
```bash
npx supabase db push
```
Expected: All three migrations applied successfully.

**Step 2: Verify in Supabase dashboard**

Check that tables `portraits`, `profiles`, `knowledge_chunks`, `conversations`, `messages`, `audit_log` exist, RLS is enabled, and the `vector` extension is active.

---

## Task 7: Supabase Client Utilities

**Files:**
- Create: `src/lib/supabase/client.ts`
- Create: `src/lib/supabase/server.ts`
- Create: `src/lib/supabase/admin.ts`
- Create: `src/lib/supabase/types.ts`

**Step 1: Generate database types**

Run:
```bash
npx supabase gen types typescript --linked > src/lib/supabase/types.ts
```

**Step 2: Create browser client**

Create `src/lib/supabase/client.ts`:

```typescript
import { createBrowserClient } from '@supabase/ssr'
import type { Database } from './types'

export function createClient() {
  return createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**Step 3: Create server client**

Create `src/lib/supabase/server.ts`:

```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import type { Database } from './types'

export async function createServerSupabaseClient() {
  const cookieStore = await cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Called from Server Component — ignore
          }
        },
      },
    }
  )
}
```

**Step 4: Create admin client (service role)**

Create `src/lib/supabase/admin.ts`:

```typescript
import { createClient } from '@supabase/supabase-js'
import type { Database } from './types'

export function createAdminClient() {
  return createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    { auth: { autoRefreshToken: false, persistSession: false } }
  )
}
```

**Step 5: Commit**

Run:
```bash
git add src/lib/supabase/
git commit -m "feat: add Supabase client utilities (browser, server, admin)"
```

---

## Task 8: Auth Middleware

**Files:**
- Create: `src/middleware.ts`
- Create: `src/app/auth/callback/route.ts`

**Step 1: Create middleware**

Create `src/middleware.ts`:

```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            request.cookies.set(name, value)
          )
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  // Protect all routes except auth-related and public assets
  const isAuthRoute = request.nextUrl.pathname.startsWith('/auth')
  const isApiRoute = request.nextUrl.pathname.startsWith('/api')
  const isLoginPage = request.nextUrl.pathname === '/login'

  if (!user && !isAuthRoute && !isLoginPage && !isApiRoute) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```

**Step 2: Create auth callback route**

Create `src/app/auth/callback/route.ts`:

```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/'

  if (code) {
    const cookieStore = await cookies()
    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() { return cookieStore.getAll() },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          },
        },
      }
    )
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  return NextResponse.redirect(`${origin}/login?error=auth`)
}
```

**Step 3: Commit**

Run:
```bash
git add src/middleware.ts src/app/auth/
git commit -m "feat: add Supabase auth middleware and callback route"
```

---

## Task 9: Login Page (Magic Link)

**Files:**
- Create: `src/app/login/page.tsx`
- Create: `src/app/login/actions.ts`

**Step 1: Create login server action**

Create `src/app/login/actions.ts`:

```typescript
'use server'

import { createServerSupabaseClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export async function loginWithMagicLink(formData: FormData) {
  const email = formData.get('email') as string
  const supabase = await createServerSupabaseClient()

  const { error } = await supabase.auth.signInWithOtp({
    email,
    options: {
      emailRedirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`,
    },
  })

  if (error) {
    return { error: error.message }
  }

  return { success: true }
}

export async function logout() {
  const supabase = await createServerSupabaseClient()
  await supabase.auth.signOut()
  redirect('/login')
}
```

**Step 2: Create login page**

Create `src/app/login/page.tsx`:

```tsx
'use client'

import { useState } from 'react'
import { loginWithMagicLink } from './actions'

export default function LoginPage() {
  const [email, setEmail] = useState('')
  const [sent, setSent] = useState(false)
  const [error, setError] = useState('')
  const [loading, setLoading] = useState(false)

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)
    setError('')

    const formData = new FormData()
    formData.set('email', email)
    const result = await loginWithMagicLink(formData)

    if (result.error) {
      setError(result.error)
    } else {
      setSent(true)
    }
    setLoading(false)
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-stone-50">
      <div className="w-full max-w-md p-8">
        <h1 className="text-2xl font-light tracking-tight text-stone-900 mb-2">
          Neural Heirloom
        </h1>
        <p className="text-stone-500 mb-8 text-sm">
          Enter your email to sign in
        </p>

        {sent ? (
          <div className="text-stone-700 bg-stone-100 rounded-lg p-4 text-sm">
            Check your email for a sign-in link.
          </div>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="you@example.com"
              required
              className="w-full px-4 py-3 border border-stone-200 rounded-lg text-sm
                         focus:outline-none focus:ring-2 focus:ring-stone-900 focus:border-transparent
                         bg-white text-stone-900 placeholder:text-stone-400"
            />
            {error && <p className="text-red-600 text-sm">{error}</p>}
            <button
              type="submit"
              disabled={loading}
              className="w-full py-3 bg-stone-900 text-white rounded-lg text-sm font-medium
                         hover:bg-stone-800 disabled:opacity-50 transition-colors"
            >
              {loading ? 'Sending...' : 'Continue with Email'}
            </button>
          </form>
        )}
      </div>
    </div>
  )
}
```

**Step 3: Commit**

Run:
```bash
git add src/app/login/
git commit -m "feat: add magic link login page"
```

---

## Task 10: Ingestion Pipeline — Chunking & Embedding Utilities

**Files:**
- Create: `src/lib/ingest/chunker.ts`
- Create: `src/lib/ingest/embeddings.ts`
- Create: `tests/lib/ingest/chunker.test.ts`

**Step 1: Write chunker test**

Create `tests/lib/ingest/chunker.test.ts`:

```typescript
import { describe, it, expect } from 'vitest'
import { chunkText } from '@/lib/ingest/chunker'

describe('chunkText', () => {
  it('splits text into chunks respecting paragraph boundaries', () => {
    const text = 'Paragraph one.\n\nParagraph two.\n\nParagraph three.'
    const chunks = chunkText(text, { maxChunkSize: 30, overlap: 0 })
    expect(chunks.length).toBeGreaterThan(1)
    chunks.forEach(c => expect(c.length).toBeLessThanOrEqual(30))
  })

  it('returns full text as single chunk when under max size', () => {
    const text = 'Short text.'
    const chunks = chunkText(text, { maxChunkSize: 1000, overlap: 0 })
    expect(chunks).toEqual(['Short text.'])
  })

  it('preserves content without data loss', () => {
    const text = 'A.\n\nB.\n\nC.'
    const chunks = chunkText(text, { maxChunkSize: 5, overlap: 0 })
    const reassembled = chunks.join('')
    expect(reassembled).toContain('A.')
    expect(reassembled).toContain('B.')
    expect(reassembled).toContain('C.')
  })
})
```

**Step 2: Set up Vitest config**

Create `vitest.config.ts`:

```typescript
import { defineConfig } from 'vitest/config'
import path from 'path'

export default defineConfig({
  test: {
    environment: 'jsdom',
    globals: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})
```

**Step 3: Run test — verify it fails**

Run: `npx vitest run tests/lib/ingest/chunker.test.ts`
Expected: FAIL — module not found.

**Step 4: Implement chunker**

Create `src/lib/ingest/chunker.ts`:

```typescript
interface ChunkOptions {
  maxChunkSize?: number
  overlap?: number
}

export function chunkText(
  text: string,
  options: ChunkOptions = {}
): string[] {
  const { maxChunkSize = 1500, overlap = 200 } = options

  const paragraphs = text.split(/\n\n+/).filter(p => p.trim())
  const chunks: string[] = []
  let current = ''

  for (const paragraph of paragraphs) {
    if (current && (current.length + paragraph.length + 2) > maxChunkSize) {
      chunks.push(current.trim())
      // Overlap: keep tail of previous chunk
      if (overlap > 0) {
        current = current.slice(-overlap) + '\n\n' + paragraph
      } else {
        current = paragraph
      }
    } else {
      current = current ? current + '\n\n' + paragraph : paragraph
    }
  }

  if (current.trim()) {
    chunks.push(current.trim())
  }

  return chunks.length > 0 ? chunks : [text]
}
```

**Step 5: Run test — verify it passes**

Run: `npx vitest run tests/lib/ingest/chunker.test.ts`
Expected: PASS

**Step 6: Create embeddings utility**

Create `src/lib/ingest/embeddings.ts`:

```typescript
import OpenAI from 'openai'

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

export async function generateEmbedding(text: string): Promise<number[]> {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  })
  return response.data[0].embedding
}

export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: texts,
  })
  return response.data.map(d => d.embedding)
}
```

**Step 7: Commit**

Run:
```bash
git add src/lib/ingest/ tests/ vitest.config.ts
git commit -m "feat: add text chunker with tests and embedding utility"
```

---

## Task 11: Ingest API Route

**Files:**
- Create: `src/app/api/ingest/route.ts`

**Step 1: Create ingest route**

Create `src/app/api/ingest/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { chunkText } from '@/lib/ingest/chunker'
import { generateEmbeddings } from '@/lib/ingest/embeddings'

export async function POST(request: NextRequest) {
  const authHeader = request.headers.get('authorization')
  if (authHeader !== `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const {
    portrait_id,
    content,
    source_title,
    source_type = 'transcript',
    source_date,
    min_tier = 'public',
    chunk_options,
  } = body

  if (!portrait_id || !content) {
    return NextResponse.json(
      { error: 'portrait_id and content are required' },
      { status: 400 }
    )
  }

  const chunks = chunkText(content, chunk_options)
  const embeddings = await generateEmbeddings(chunks)

  const supabase = createAdminClient()

  const rows = chunks.map((chunk, i) => ({
    portrait_id,
    content: chunk,
    embedding: JSON.stringify(embeddings[i]),
    source_title,
    source_type,
    source_date,
    min_tier,
    chunk_index: i,
  }))

  const { data, error } = await supabase
    .from('knowledge_chunks')
    .insert(rows)
    .select('id')

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  // Audit log
  await supabase.from('audit_log').insert({
    action: 'ingest',
    resource_type: 'knowledge_chunks',
    metadata: {
      portrait_id,
      source_title,
      chunks_created: chunks.length,
    },
  })

  return NextResponse.json({
    chunks_created: chunks.length,
    ids: data.map(d => d.id),
  })
}
```

**Step 2: Commit**

Run:
```bash
git add src/app/api/ingest/
git commit -m "feat: add admin-only ingest API route"
```

---

## Task 12: Chat API Route (RAG Pipeline)

**Files:**
- Create: `src/lib/rag/retrieve.ts`
- Create: `src/app/api/chat/route.ts`

**Step 1: Create retrieval utility**

Create `src/lib/rag/retrieve.ts`:

```typescript
import { SupabaseClient } from '@supabase/supabase-js'
import { generateEmbedding } from '@/lib/ingest/embeddings'

export async function retrieveRelevantChunks(
  supabase: SupabaseClient,
  query: string,
  portraitId: string,
  limit: number = 8
) {
  const embedding = await generateEmbedding(query)

  // RLS automatically filters by user's access_tier
  const { data, error } = await supabase.rpc('match_knowledge_chunks', {
    query_embedding: JSON.stringify(embedding),
    match_portrait_id: portraitId,
    match_count: limit,
  })

  if (error) throw error
  return data ?? []
}
```

**Step 2: Create the matching RPC function migration**

Create `supabase/migrations/00004_match_chunks_rpc.sql`:

```sql
CREATE OR REPLACE FUNCTION match_knowledge_chunks(
  query_embedding vector(1536),
  match_portrait_id UUID,
  match_count INTEGER DEFAULT 8
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  source_title TEXT,
  source_type TEXT,
  similarity FLOAT
)
LANGUAGE sql STABLE
AS $$
  SELECT
    kc.id,
    kc.content,
    kc.source_title,
    kc.source_type,
    1 - (kc.embedding <=> query_embedding) AS similarity
  FROM knowledge_chunks kc
  WHERE kc.portrait_id = match_portrait_id
    AND kc.embedding IS NOT NULL
  ORDER BY kc.embedding <=> query_embedding
  LIMIT match_count;
$$;
```

> **Note:** This RPC runs as the calling user, so RLS on `knowledge_chunks` still applies — tier filtering is automatic.

**Step 3: Create chat API route**

Create `src/app/api/chat/route.ts`:

```typescript
import { NextRequest } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { retrieveRelevantChunks } from '@/lib/rag/retrieve'
import Anthropic from '@anthropic-ai/sdk'

const anthropic = new Anthropic()

export async function POST(request: NextRequest) {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  const { message, conversation_id, portrait_id } = await request.json()

  if (!message || !portrait_id) {
    return new Response('message and portrait_id are required', { status: 400 })
  }

  // Get portrait system prompt
  const { data: portrait } = await supabase
    .from('portraits')
    .select('system_prompt, display_name')
    .eq('id', portrait_id)
    .single()

  if (!portrait) {
    return new Response('Portrait not found', { status: 404 })
  }

  // Retrieve relevant knowledge chunks (RLS filters by user tier)
  const chunks = await retrieveRelevantChunks(supabase, message, portrait_id)

  // Build context from retrieved chunks
  const context = chunks
    .map(c => `[Source: ${c.source_title ?? 'Unknown'}]\n${c.content}`)
    .join('\n\n---\n\n')

  // Get or create conversation
  let convId = conversation_id
  if (!convId) {
    const { data: conv } = await supabase
      .from('conversations')
      .insert({ user_id: user.id, portrait_id, title: message.slice(0, 100) })
      .select('id')
      .single()
    convId = conv?.id
  }

  // Get conversation history
  const { data: history } = await supabase
    .from('messages')
    .select('role, content')
    .eq('conversation_id', convId)
    .order('created_at', { ascending: true })
    .limit(20)

  // Save user message
  await supabase.from('messages').insert({
    conversation_id: convId,
    role: 'user',
    content: message,
    chunks_referenced: chunks.map(c => c.id),
  })

  // Build messages array for Claude
  const messages: Anthropic.MessageParam[] = [
    ...(history ?? []).map(m => ({
      role: m.role as 'user' | 'assistant',
      content: m.content,
    })),
    { role: 'user', content: message },
  ]

  // System prompt with RAG context
  const systemPrompt = `${portrait.system_prompt}

---
REFERENCE MATERIAL (from ${portrait.display_name}'s own words and writings):

${context}

---
Use the reference material above to ground your responses in what ${portrait.display_name} has actually said and expressed. If the reference material doesn't contain relevant information for the question, draw on the persona description but note that you're speaking more generally.`

  // Stream response
  const stream = await anthropic.messages.stream({
    model: 'claude-sonnet-4-6',
    max_tokens: 2048,
    system: systemPrompt,
    messages,
  })

  // Create a ReadableStream from the Anthropic stream
  const encoder = new TextEncoder()
  const readable = new ReadableStream({
    async start(controller) {
      let fullResponse = ''

      for await (const event of stream) {
        if (event.type === 'content_block_delta' && event.delta.type === 'text_delta') {
          fullResponse += event.delta.text
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ text: event.delta.text })}\n\n`))
        }
      }

      // Save assistant message
      await supabase.from('messages').insert({
        conversation_id: convId,
        role: 'assistant',
        content: fullResponse,
      })

      // Audit log
      const adminSupabase = (await import('@/lib/supabase/admin')).createAdminClient()
      await adminSupabase.from('audit_log').insert({
        user_id: user.id,
        action: 'chat',
        resource_type: 'conversation',
        resource_id: convId,
        metadata: { portrait_id, chunks_used: chunks.length },
      })

      controller.enqueue(encoder.encode(`data: ${JSON.stringify({ done: true, conversation_id: convId })}\n\n`))
      controller.close()
    },
  })

  return new Response(readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive',
    },
  })
}
```

**Step 4: Commit**

Run:
```bash
git add src/lib/rag/ src/app/api/chat/ supabase/migrations/00004_match_chunks_rpc.sql
git commit -m "feat: add RAG chat API with streaming and tiered retrieval"
```

---

## Task 13: Conversation API Routes

**Files:**
- Create: `src/app/api/conversations/route.ts`
- Create: `src/app/api/conversations/[id]/route.ts`

**Step 1: Create list conversations route**

Create `src/app/api/conversations/route.ts`:

```typescript
import { NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'

export async function GET() {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { data, error } = await supabase
    .from('conversations')
    .select('id, title, portrait_id, created_at, updated_at')
    .order('updated_at', { ascending: false })

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json(data)
}
```

**Step 2: Create single conversation route**

Create `src/app/api/conversations/[id]/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { data: conversation } = await supabase
    .from('conversations')
    .select('id, title, portrait_id, created_at')
    .eq('id', id)
    .single()

  if (!conversation) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 })
  }

  const { data: messages } = await supabase
    .from('messages')
    .select('id, role, content, created_at')
    .eq('conversation_id', id)
    .order('created_at', { ascending: true })

  return NextResponse.json({ ...conversation, messages })
}
```

**Step 3: Commit**

Run:
```bash
git add src/app/api/conversations/
git commit -m "feat: add conversation list and detail API routes"
```

---

## Task 14: Chat UI — Core Components

**Files:**
- Create: `src/components/chat/ChatInterface.tsx`
- Create: `src/components/chat/MessageBubble.tsx`
- Create: `src/components/chat/ChatInput.tsx`
- Create: `src/lib/hooks/useChat.ts`

**Step 1: Create useChat hook**

Create `src/lib/hooks/useChat.ts`:

```typescript
'use client'

import { useState, useCallback, useRef } from 'react'

interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
}

export function useChat(portraitId: string) {
  const [messages, setMessages] = useState<Message[]>([])
  const [isStreaming, setIsStreaming] = useState(false)
  const [conversationId, setConversationId] = useState<string | null>(null)
  const abortRef = useRef<AbortController | null>(null)

  const sendMessage = useCallback(async (content: string) => {
    const userMsg: Message = {
      id: crypto.randomUUID(),
      role: 'user',
      content,
    }
    setMessages(prev => [...prev, userMsg])
    setIsStreaming(true)

    const assistantId = crypto.randomUUID()
    setMessages(prev => [...prev, { id: assistantId, role: 'assistant', content: '' }])

    try {
      abortRef.current = new AbortController()
      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          portrait_id: portraitId,
          conversation_id: conversationId,
        }),
        signal: abortRef.current.signal,
      })

      if (!res.ok) throw new Error('Chat request failed')

      const reader = res.body!.getReader()
      const decoder = new TextDecoder()

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const text = decoder.decode(value)
        const lines = text.split('\n').filter(l => l.startsWith('data: '))

        for (const line of lines) {
          const data = JSON.parse(line.slice(6))
          if (data.text) {
            setMessages(prev =>
              prev.map(m =>
                m.id === assistantId
                  ? { ...m, content: m.content + data.text }
                  : m
              )
            )
          }
          if (data.conversation_id) {
            setConversationId(data.conversation_id)
          }
        }
      }
    } catch (err) {
      if ((err as Error).name !== 'AbortError') {
        setMessages(prev =>
          prev.map(m =>
            m.id === assistantId
              ? { ...m, content: 'Something went wrong. Please try again.' }
              : m
          )
        )
      }
    } finally {
      setIsStreaming(false)
    }
  }, [portraitId, conversationId])

  const loadConversation = useCallback(async (convId: string) => {
    const res = await fetch(`/api/conversations/${convId}`)
    if (!res.ok) return
    const data = await res.json()
    setConversationId(convId)
    setMessages(data.messages.map((m: any) => ({
      id: m.id,
      role: m.role,
      content: m.content,
    })))
  }, [])

  return { messages, isStreaming, conversationId, sendMessage, loadConversation }
}
```

**Step 2: Create MessageBubble component**

Create `src/components/chat/MessageBubble.tsx`:

```tsx
interface MessageBubbleProps {
  role: 'user' | 'assistant'
  content: string
  portraitName?: string
}

export function MessageBubble({ role, content, portraitName }: MessageBubbleProps) {
  const isUser = role === 'user'

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
      <div className={`max-w-[75%] ${isUser
        ? 'bg-stone-900 text-white rounded-2xl rounded-br-sm'
        : 'bg-stone-100 text-stone-900 rounded-2xl rounded-bl-sm'
      } px-4 py-3`}>
        {!isUser && (
          <p className="text-xs font-medium text-stone-500 mb-1">{portraitName}</p>
        )}
        <p className="text-sm leading-relaxed whitespace-pre-wrap">{content}</p>
      </div>
    </div>
  )
}
```

**Step 3: Create ChatInput component**

Create `src/components/chat/ChatInput.tsx`:

```tsx
'use client'

import { useState, useRef, useEffect } from 'react'

interface ChatInputProps {
  onSend: (message: string) => void
  disabled?: boolean
}

export function ChatInput({ onSend, disabled }: ChatInputProps) {
  const [value, setValue] = useState('')
  const textareaRef = useRef<HTMLTextAreaElement>(null)

  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto'
      textareaRef.current.style.height = `${textareaRef.current.scrollHeight}px`
    }
  }, [value])

  function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!value.trim() || disabled) return
    onSend(value.trim())
    setValue('')
  }

  function handleKeyDown(e: React.KeyboardEvent) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSubmit(e)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="flex items-end gap-3 p-4 border-t border-stone-200">
      <textarea
        ref={textareaRef}
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Ask a question..."
        rows={1}
        disabled={disabled}
        className="flex-1 resize-none bg-stone-50 rounded-xl px-4 py-3 text-sm
                   border border-stone-200 focus:outline-none focus:ring-2
                   focus:ring-stone-900 focus:border-transparent
                   disabled:opacity-50 max-h-32"
      />
      <button
        type="submit"
        disabled={disabled || !value.trim()}
        className="px-4 py-3 bg-stone-900 text-white rounded-xl text-sm font-medium
                   hover:bg-stone-800 disabled:opacity-50 transition-colors shrink-0"
      >
        Send
      </button>
    </form>
  )
}
```

**Step 4: Create ChatInterface component**

Create `src/components/chat/ChatInterface.tsx`:

```tsx
'use client'

import { useRef, useEffect } from 'react'
import { useChat } from '@/lib/hooks/useChat'
import { MessageBubble } from './MessageBubble'
import { ChatInput } from './ChatInput'

interface ChatInterfaceProps {
  portraitId: string
  portraitName: string
  initialConversationId?: string
}

export function ChatInterface({ portraitId, portraitName, initialConversationId }: ChatInterfaceProps) {
  const { messages, isStreaming, sendMessage, loadConversation } = useChat(portraitId)
  const messagesEndRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (initialConversationId) {
      loadConversation(initialConversationId)
    }
  }, [initialConversationId, loadConversation])

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }, [messages])

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto p-6">
        {messages.length === 0 && (
          <div className="flex items-center justify-center h-full text-stone-400 text-sm">
            Start a conversation with {portraitName}
          </div>
        )}
        {messages.map(msg => (
          <MessageBubble
            key={msg.id}
            role={msg.role}
            content={msg.content}
            portraitName={portraitName}
          />
        ))}
        <div ref={messagesEndRef} />
      </div>
      <ChatInput onSend={sendMessage} disabled={isStreaming} />
    </div>
  )
}
```

**Step 5: Commit**

Run:
```bash
git add src/components/chat/ src/lib/hooks/
git commit -m "feat: add chat UI components with streaming support"
```

---

## Task 15: Chat Page

**Files:**
- Create: `src/app/(authenticated)/chat/page.tsx`
- Create: `src/app/(authenticated)/layout.tsx`

**Step 1: Create authenticated layout**

Create `src/app/(authenticated)/layout.tsx`:

```tsx
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { logout } from '@/app/login/actions'

export default async function AuthenticatedLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  return (
    <div className="min-h-screen bg-stone-50 flex flex-col">
      <header className="border-b border-stone-200 bg-white px-6 py-3 flex items-center justify-between">
        <h1 className="text-sm font-medium tracking-tight text-stone-900">Neural Heirloom</h1>
        <form action={logout}>
          <button className="text-xs text-stone-500 hover:text-stone-900 transition-colors">
            Sign out
          </button>
        </form>
      </header>
      <main className="flex-1 flex">{children}</main>
    </div>
  )
}
```

**Step 2: Create chat page**

Create `src/app/(authenticated)/chat/page.tsx`:

```tsx
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { ChatInterface } from '@/components/chat/ChatInterface'

export default async function ChatPage() {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  // Get the first portrait (single-portrait for Phase 1)
  const { data: portrait } = await supabase
    .from('portraits')
    .select('id, display_name')
    .limit(1)
    .single()

  if (!portrait) {
    return (
      <div className="flex-1 flex items-center justify-center text-stone-500 text-sm">
        No portrait configured yet.
      </div>
    )
  }

  return (
    <div className="flex-1 flex flex-col">
      <ChatInterface
        portraitId={portrait.id}
        portraitName={portrait.display_name}
      />
    </div>
  )
}
```

**Step 3: Update root page to redirect**

Modify `src/app/page.tsx` to redirect authenticated users to `/chat`:

```tsx
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'

export default async function Home() {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (user) redirect('/chat')
  redirect('/login')
}
```

**Step 4: Commit**

Run:
```bash
git add src/app/
git commit -m "feat: add chat page with authenticated layout"
```

---

## Task 16: Admin — Seed Portrait & Test End-to-End

**Files:**
- Create: `scripts/seed-portrait.ts`

**Step 1: Create seed script**

Create `scripts/seed-portrait.ts`:

```typescript
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

async function seed() {
  const { data, error } = await supabase
    .from('portraits')
    .upsert({
      slug: 'kirit-shah',
      display_name: 'Kirit Shah',
      system_prompt: `You are a portrait of Kirit Shah, the founder and managing director of Precious Shipping Public Company Limited, based in Bangkok, Thailand. You embody his perspective, values, and communication style.

Key traits:
- Direct and forthright communicator
- Deep expertise in shipping, logistics, and commodity markets
- Values long-term thinking over short-term gains
- Believes in transparency with shareholders
- Draws on decades of experience in the maritime industry

Respond as Kirit would — grounded, thoughtful, and informed by real experience. When referencing specific facts or events, draw on the provided reference material. If asked about something not in your reference material, you may share a perspective consistent with Kirit's known values and thinking, but be transparent that you're speaking more generally.

Do not break character. Do not mention that you are an AI. Speak in first person as Kirit Shah.`,
      avatar_url: null,
    }, { onConflict: 'slug' })
    .select()

  if (error) {
    console.error('Error seeding portrait:', error)
    process.exit(1)
  }

  console.log('Portrait seeded:', data)
}

seed()
```

**Step 2: Run seed script**

Run:
```bash
npx tsx scripts/seed-portrait.ts
```
Expected: Portrait row created/updated.

**Step 3: Commit**

Run:
```bash
git add scripts/
git commit -m "feat: add portrait seed script"
```

---

## Task 17: Admin Panel — User Management

**Files:**
- Create: `src/app/(authenticated)/admin/page.tsx`
- Create: `src/app/(authenticated)/admin/users/page.tsx`
- Create: `src/app/(authenticated)/admin/users/actions.ts`
- Create: `src/app/(authenticated)/admin/layout.tsx`

**Step 1: Create admin layout with nav**

Create `src/app/(authenticated)/admin/layout.tsx`:

```tsx
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { createAdminClient } from '@/lib/supabase/admin'
import { redirect } from 'next/navigation'
import Link from 'next/link'

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const supabase = await createServerSupabaseClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  // Check admin status — for Phase 1, admin = family tier
  const admin = createAdminClient()
  const { data: profile } = await admin
    .from('profiles')
    .select('access_tier')
    .eq('id', user.id)
    .single()

  if (profile?.access_tier !== 'family') {
    redirect('/chat')
  }

  return (
    <div className="flex flex-1">
      <nav className="w-48 border-r border-stone-200 bg-white p-4 space-y-1">
        <Link href="/admin" className="block text-sm text-stone-600 hover:text-stone-900 px-2 py-1.5 rounded hover:bg-stone-50">
          Overview
        </Link>
        <Link href="/admin/users" className="block text-sm text-stone-600 hover:text-stone-900 px-2 py-1.5 rounded hover:bg-stone-50">
          Users
        </Link>
        <Link href="/admin/ingest" className="block text-sm text-stone-600 hover:text-stone-900 px-2 py-1.5 rounded hover:bg-stone-50">
          Ingestion
        </Link>
      </nav>
      <div className="flex-1 p-6">{children}</div>
    </div>
  )
}
```

**Step 2: Create admin overview page**

Create `src/app/(authenticated)/admin/page.tsx`:

```tsx
import { createAdminClient } from '@/lib/supabase/admin'

export default async function AdminOverview() {
  const supabase = createAdminClient()

  const [
    { count: userCount },
    { count: chunkCount },
    { count: conversationCount },
  ] = await Promise.all([
    supabase.from('profiles').select('*', { count: 'exact', head: true }),
    supabase.from('knowledge_chunks').select('*', { count: 'exact', head: true }),
    supabase.from('conversations').select('*', { count: 'exact', head: true }),
  ])

  return (
    <div>
      <h2 className="text-lg font-medium text-stone-900 mb-6">Admin Overview</h2>
      <div className="grid grid-cols-3 gap-4">
        {[
          { label: 'Users', value: userCount ?? 0 },
          { label: 'Knowledge Chunks', value: chunkCount ?? 0 },
          { label: 'Conversations', value: conversationCount ?? 0 },
        ].map(stat => (
          <div key={stat.label} className="bg-white border border-stone-200 rounded-lg p-4">
            <p className="text-xs text-stone-500">{stat.label}</p>
            <p className="text-2xl font-light text-stone-900 mt-1">{stat.value}</p>
          </div>
        ))}
      </div>
    </div>
  )
}
```

**Step 3: Create user management actions**

Create `src/app/(authenticated)/admin/users/actions.ts`:

```typescript
'use server'

import { createAdminClient } from '@/lib/supabase/admin'

export async function updateUserTier(userId: string, tier: string) {
  const supabase = createAdminClient()
  const { error } = await supabase
    .from('profiles')
    .update({ access_tier: tier })
    .eq('id', userId)

  if (error) return { error: error.message }

  await supabase.from('audit_log').insert({
    action: 'update_access_tier',
    resource_type: 'profile',
    resource_id: userId,
    metadata: { new_tier: tier },
  })

  return { success: true }
}

export async function inviteUser(email: string, tier: string, portraitId: string) {
  const supabase = createAdminClient()

  const { data, error } = await supabase.auth.admin.inviteUserByEmail(email, {
    data: { access_tier: tier },
    redirectTo: `${process.env.NEXT_PUBLIC_APP_URL}/auth/callback`,
  })

  if (error) return { error: error.message }

  // Update portrait_id on the auto-created profile
  if (data.user) {
    await supabase
      .from('profiles')
      .update({ portrait_id: portraitId })
      .eq('id', data.user.id)
  }

  await supabase.from('audit_log').insert({
    action: 'invite_user',
    resource_type: 'profile',
    metadata: { email, tier },
  })

  return { success: true }
}
```

**Step 4: Create users page**

Create `src/app/(authenticated)/admin/users/page.tsx`:

```tsx
import { createAdminClient } from '@/lib/supabase/admin'
import { updateUserTier, inviteUser } from './actions'

export default async function UsersPage() {
  const supabase = createAdminClient()
  const { data: users } = await supabase
    .from('profiles')
    .select('id, email, full_name, access_tier, created_at')
    .order('created_at', { ascending: false })

  const { data: portraits } = await supabase
    .from('portraits')
    .select('id, display_name')

  return (
    <div>
      <h2 className="text-lg font-medium text-stone-900 mb-6">User Management</h2>

      {/* Invite form */}
      <form
        action={async (formData: FormData) => {
          'use server'
          await inviteUser(
            formData.get('email') as string,
            formData.get('tier') as string,
            formData.get('portrait_id') as string
          )
        }}
        className="bg-white border border-stone-200 rounded-lg p-4 mb-6 flex gap-3 items-end"
      >
        <div className="flex-1">
          <label className="text-xs text-stone-500 block mb-1">Email</label>
          <input name="email" type="email" required
            className="w-full px-3 py-2 border border-stone-200 rounded text-sm" />
        </div>
        <div>
          <label className="text-xs text-stone-500 block mb-1">Tier</label>
          <select name="tier" className="px-3 py-2 border border-stone-200 rounded text-sm">
            <option value="public">Public</option>
            <option value="acquaintance">Acquaintance</option>
            <option value="colleague">Colleague</option>
            <option value="family">Family</option>
          </select>
        </div>
        <div>
          <label className="text-xs text-stone-500 block mb-1">Portrait</label>
          <select name="portrait_id" className="px-3 py-2 border border-stone-200 rounded text-sm">
            {portraits?.map(p => (
              <option key={p.id} value={p.id}>{p.display_name}</option>
            ))}
          </select>
        </div>
        <button type="submit"
          className="px-4 py-2 bg-stone-900 text-white rounded text-sm hover:bg-stone-800">
          Invite
        </button>
      </form>

      {/* Users table */}
      <div className="bg-white border border-stone-200 rounded-lg overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-stone-50 text-stone-500 text-xs">
            <tr>
              <th className="text-left px-4 py-3">Email</th>
              <th className="text-left px-4 py-3">Name</th>
              <th className="text-left px-4 py-3">Tier</th>
              <th className="text-left px-4 py-3">Joined</th>
            </tr>
          </thead>
          <tbody>
            {users?.map(user => (
              <tr key={user.id} className="border-t border-stone-100">
                <td className="px-4 py-3">{user.email}</td>
                <td className="px-4 py-3 text-stone-600">{user.full_name || '—'}</td>
                <td className="px-4 py-3">
                  <form action={async (formData: FormData) => {
                    'use server'
                    await updateUserTier(user.id, formData.get('tier') as string)
                  }}>
                    <select name="tier" defaultValue={user.access_tier}
                      onChange={(e) => (e.target as any).form?.requestSubmit()}
                      className="px-2 py-1 border border-stone-200 rounded text-xs">
                      <option value="public">Public</option>
                      <option value="acquaintance">Acquaintance</option>
                      <option value="colleague">Colleague</option>
                      <option value="family">Family</option>
                    </select>
                  </form>
                </td>
                <td className="px-4 py-3 text-stone-400 text-xs">
                  {new Date(user.created_at).toLocaleDateString()}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

**Step 5: Commit**

Run:
```bash
git add src/app/\(authenticated\)/admin/
git commit -m "feat: add admin panel with user management and invite"
```

---

## Task 18: Admin — Ingestion UI

**Files:**
- Create: `src/app/(authenticated)/admin/ingest/page.tsx`
- Create: `src/app/(authenticated)/admin/ingest/actions.ts`

**Step 1: Create ingestion server action**

Create `src/app/(authenticated)/admin/ingest/actions.ts`:

```typescript
'use server'

import { chunkText } from '@/lib/ingest/chunker'
import { generateEmbeddings } from '@/lib/ingest/embeddings'
import { createAdminClient } from '@/lib/supabase/admin'

export async function ingestContent(formData: FormData) {
  const portraitId = formData.get('portrait_id') as string
  const content = formData.get('content') as string
  const sourceTitle = formData.get('source_title') as string
  const sourceType = formData.get('source_type') as string
  const minTier = formData.get('min_tier') as string

  if (!portraitId || !content) {
    return { error: 'Portrait and content are required' }
  }

  const chunks = chunkText(content)
  const embeddings = await generateEmbeddings(chunks)
  const supabase = createAdminClient()

  const rows = chunks.map((chunk, i) => ({
    portrait_id: portraitId,
    content: chunk,
    embedding: JSON.stringify(embeddings[i]),
    source_title: sourceTitle || null,
    source_type: sourceType || 'transcript',
    min_tier: minTier || 'public',
    chunk_index: i,
  }))

  const { error } = await supabase.from('knowledge_chunks').insert(rows)

  if (error) return { error: error.message }

  await supabase.from('audit_log').insert({
    action: 'ingest',
    resource_type: 'knowledge_chunks',
    metadata: { portrait_id: portraitId, source_title: sourceTitle, chunks_created: chunks.length },
  })

  return { success: true, chunksCreated: chunks.length }
}
```

**Step 2: Create ingestion page**

Create `src/app/(authenticated)/admin/ingest/page.tsx`:

```tsx
'use client'

import { useState } from 'react'
import { ingestContent } from './actions'

export default function IngestPage() {
  const [result, setResult] = useState<{ success?: boolean; chunksCreated?: number; error?: string } | null>(null)
  const [loading, setLoading] = useState(false)

  async function handleSubmit(formData: FormData) {
    setLoading(true)
    setResult(null)
    const res = await ingestContent(formData)
    setResult(res)
    setLoading(false)
  }

  return (
    <div>
      <h2 className="text-lg font-medium text-stone-900 mb-6">Ingest Content</h2>

      <form action={handleSubmit} className="bg-white border border-stone-200 rounded-lg p-6 space-y-4 max-w-2xl">
        <div>
          <label className="text-xs text-stone-500 block mb-1">Portrait ID</label>
          <input name="portrait_id" required
            className="w-full px-3 py-2 border border-stone-200 rounded text-sm" />
        </div>
        <div>
          <label className="text-xs text-stone-500 block mb-1">Source Title</label>
          <input name="source_title"
            className="w-full px-3 py-2 border border-stone-200 rounded text-sm" />
        </div>
        <div className="flex gap-4">
          <div className="flex-1">
            <label className="text-xs text-stone-500 block mb-1">Source Type</label>
            <select name="source_type" className="w-full px-3 py-2 border border-stone-200 rounded text-sm">
              <option value="transcript">Transcript</option>
              <option value="interview">Interview</option>
              <option value="letter">Letter</option>
              <option value="article">Article</option>
              <option value="other">Other</option>
            </select>
          </div>
          <div className="flex-1">
            <label className="text-xs text-stone-500 block mb-1">Minimum Tier</label>
            <select name="min_tier" className="w-full px-3 py-2 border border-stone-200 rounded text-sm">
              <option value="public">Public</option>
              <option value="acquaintance">Acquaintance</option>
              <option value="colleague">Colleague</option>
              <option value="family">Family</option>
            </select>
          </div>
        </div>
        <div>
          <label className="text-xs text-stone-500 block mb-1">Content</label>
          <textarea name="content" required rows={12}
            placeholder="Paste transcript or document text here..."
            className="w-full px-3 py-2 border border-stone-200 rounded text-sm resize-y" />
        </div>
        <button type="submit" disabled={loading}
          className="px-4 py-2 bg-stone-900 text-white rounded text-sm hover:bg-stone-800 disabled:opacity-50">
          {loading ? 'Processing...' : 'Ingest Content'}
        </button>

        {result?.success && (
          <p className="text-green-700 text-sm bg-green-50 rounded p-3">
            Successfully created {result.chunksCreated} chunks.
          </p>
        )}
        {result?.error && (
          <p className="text-red-700 text-sm bg-red-50 rounded p-3">{result.error}</p>
        )}
      </form>
    </div>
  )
}
```

**Step 3: Commit**

Run:
```bash
git add src/app/\(authenticated\)/admin/ingest/
git commit -m "feat: add admin ingestion UI"
```

---

## Task 19: Push Remaining Migration & Final Wiring

**Step 1: Push migration 00004**

Run:
```bash
npx supabase db push
```

**Step 2: Verify the dev server runs**

Run:
```bash
npm run dev
```

Visit `http://localhost:3000` — should redirect to `/login`.

**Step 3: Commit any remaining changes**

Run:
```bash
git add -A
git commit -m "chore: final wiring for Phase 1 MVP"
```

---

## Task 20: End-to-End Smoke Test

**Step 1: Seed portrait** (if not already done)

```bash
npx tsx scripts/seed-portrait.ts
```

**Step 2: Create a test user in Supabase dashboard**

Go to Supabase Dashboard → Authentication → Users → Invite user. Set their `access_tier` to `family` in the profiles table.

**Step 3: Ingest test content**

Via the admin ingestion UI or curl:

```bash
curl -X POST http://localhost:3000/api/ingest \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $SUPABASE_SERVICE_ROLE_KEY" \
  -d '{
    "portrait_id": "<portrait-uuid>",
    "content": "I have always believed that shipping is a long-term business. You cannot make decisions based on quarterly results. Our approach at Precious Shipping has always been to take the 10-year view.\n\nTransparency with shareholders is non-negotiable. They deserve to know exactly what is happening, good or bad.",
    "source_title": "Test Interview",
    "source_type": "interview",
    "min_tier": "public"
  }'
```

**Step 4: Test the chat**

Log in with the test user, navigate to `/chat`, send a message like "What is your philosophy on long-term business?" and verify:
- Streaming response appears
- Response reflects the ingested content
- Conversation persists on page refresh

**Step 5: Verify RLS**

Create a second user with `public` tier. Ingest a chunk with `min_tier: 'family'`. Verify the public user does NOT receive that chunk in their responses while the family user does.

---

## Summary

| Task | Description | Depends On |
|------|-------------|------------|
| 1 | Scaffold Next.js app | — |
| 2 | Supabase project setup | 1 |
| 3 | Core schema migration | 2 |
| 4 | RLS policies migration | 3 |
| 5 | Profile auto-creation trigger | 3 |
| 6 | Push migrations to remote | 3, 4, 5 |
| 7 | Supabase client utilities | 2 |
| 8 | Auth middleware | 7 |
| 9 | Login page (magic link) | 7, 8 |
| 10 | Chunker & embedding utilities | 1 |
| 11 | Ingest API route | 7, 10 |
| 12 | Chat API route (RAG) | 7, 10 |
| 13 | Conversation API routes | 7 |
| 14 | Chat UI components | 1 |
| 15 | Chat page | 8, 14 |
| 16 | Seed portrait script | 6, 7 |
| 17 | Admin panel — user management | 7, 9 |
| 18 | Admin — ingestion UI | 10, 17 |
| 19 | Final migration push & wiring | All |
| 20 | End-to-end smoke test | All |
